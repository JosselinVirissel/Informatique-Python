
.. _canon:

Trajectoire d'un boulet de canon
--------------------------------


Nous allons intégrer les équations du mouvement pour un boulet de canon
soumis à des forces de frottement "turbulentes" (non-linéaires):

.. math::


   \ddot{\mathbf{r}} = \mathbf{g} - \frac{\alpha}{m}v\times\mathbf{v}.

Cette équation différentielle non-linéaire du 2nd ordre doit être
réécrite sous la forme de deux équations différentielles couplées du 1er
ordre:

.. math::


   \begin{cases}
   \dot{\mathbf{r}} &= \mathbf{v} \\
   \dot{\mathbf{v}} &= \mathbf{g} - \frac{\alpha}{m}v\times\mathbf{v}.
   \end{cases}

Il s'agit donc de résoudre *une seule* équation différentielle du 1er
ordre en :math:`\mathbf{z} = (\mathbf{r},\mathbf{v})`\ .

.. code:: python

    import numpy as N
    import scipy.integrate as SI
    import matplotlib.pyplot as P

Valeurs numériques pour un boulet de canon de `36
livres <http://fr.wikipedia.org/wiki/Canon_de_36_livres>`_:

.. code:: python

    g = 9.81 # Pesanteur [m/s2]
    cx = 0.45 # Coefficient de frottement d'une sphère
    rhoAir = 1.2 # Masse volumique de l'air [kg/m3] au niveau de la mer, T=20°C
    rad = 0.1748/2 # Rayon du boulet [m]
    rho = 6.23e3 # Masse volumique du boulet [kg/m3]
    mass = 4./3.*N.pi*rad**3 * rho # Masse du boulet [kg]
    alpha = 0.5*cx*rhoAir*N.pi*rad**2 / mass # Coefficient de frottement par unité de masse
    print "Masse du boulet: %.2f kg" % mass
    print "Coefficient de frottement par unité de masse: %f S.I." % alpha

.. parsed-literal::

    Masse du boulet: 17.42 kg
    Coefficient de frottement par unité de masse: 0.000372 S.I.


Conditions initiales:

.. code:: python

    v0 = 450. # Vitesse initiale [m/s]
    alt = 45. # Inclinaison du canon [deg]
    alt *= N.pi/180. # Inclinaison [rad]
    z0 = (0.,0.,v0*N.cos(alt),v0*N.sin(alt)) # (x0,y0,vx0,vy0)

Temps caractéristique du système: :math:`t = \sqrt{\frac{m}{g\alpha}}`
(durée du régime transitoire). L'intégration des équations se fera sur
un temps caractéristique, avec des pas de temps significativement plus
petits.

.. code:: python

    dt = N.sqrt(mass/(g * alpha))
    print "Temps caractéristique: %.1f s" % dt
    t = N.linspace(0, dt, 100)

.. parsed-literal::

    Temps caractéristique: 69.1 s


Définition de la fonction :math:`\dot{\mathbf{z}}`\ , avec
:math:`\mathbf{z} = (\mathbf{r},\mathbf{v})`

.. code:: python

    def zdot(z, t):
        """Calcul de la dérivée de z=(x,y,vx,vy) à l'instant t."""
        
        x,y,vx,vy = z
        alphav = alpha * N.hypot(vx, vy)
        
        return (vx,vy,-alphav*vx,-g-alphav*vy) # dz/dt = (vx,vy,x..,y..)

Intégration numérique des équations du mouvement à l'aide de la fonction
`scipy.integrate.odeint <http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html>`_:

.. code:: python

    zs = SI.odeint(zdot, z0, t, printmessg=True)

.. parsed-literal::

    Integration successful.


Le tableau ``zs`` contient les valeurs de :math:`z` à chaque instant
:math:`t`\ : il est donc de taille ``(len(t),4)``.

.. code:: python

    ypos = zs[:,1]>=0 # y>0? 
    print "t(y~0) = %.0f s" % t[ypos][-1] # Dernier instant pour lequel y>0
    print "x(y~0) = %.0f m" % zs[ypos,0][-1] # Portée du canon
    #print "y(y~0) = %.0f m" % zs[ypos,1][-1] # ~0
    print "vitesse(y~0): %.0f m/s" % (N.hypot(zs[ypos,2][-1],zs[ypos,3][-1]))

.. parsed-literal::

    t(y~0) = 36 s
    x(y~0) = 3966 m
    vitesse(y~0): 140 m/s


.. code:: python

    fig,ax = P.subplots()
    ax.plot(zs[ypos,0],zs[ypos,1], 'b.-')
    ax.set_xlabel("x [m]")
    ax.set_ylabel("y [m]")
    ax.set_title("Trajectoire du boulet")



.. parsed-literal::

    <matplotlib.text.Text at 0x2ef3290>




.. image:: canon_files/canon_16_1.png

